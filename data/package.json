{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1673363574648475650",
        "title": "专科大三-Java-实习",
        "description": "鱼总好，想请你帮我看看简历还有什么可以优化的地方",
        "content": "马上就毕业了，然后也没有实习经历。最近才出来找工作，但是一言难尽。投的简历也蛮多的，面试机会却少的可怜。面试官问的问题有些是知道的，但是面试的时候却说不出来。想请教一下鱼总怎么样背八股文更有效率。\n\n![111.jpg](https://pic.code-nav.cn/post_picture/1615901355229052929/ITS9RXgU-111.jpg)\n\n![222.jpg](https://pic.code-nav.cn/post_picture/1615901355229052929/NXkqShTg-222.jpg)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 16,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1615901355229052929",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-26T16:12:20.000+00:00",
        "updateTime": "2023-06-27T07:59:41.000+00:00",
        "user": {
          "id": "1615901355229052929",
          "planetCode": "24021",
          "userName": "鱼刺",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1615901355229052929/NnY8jEo1-头像.jpg",
          "gender": 1,
          "userProfile": "练习时长一年半的Java练习生",
          "userRole": "vip",
          "interests": [],
          "place": "广州",
          "birthday": "2001-10-08",
          "school": null,
          "major": null,
          "education": "专科",
          "graduationYear": 2023,
          "jobStatus": "求职中",
          "company": null,
          "job": "后端",
          "workYear": 0,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-06-19T14:42:21.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-19T02:37:59.000+00:00",
          "updateTime": "2023-06-26T15:29:36.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1672134026791542786",
        "title": "React 的常见初学者错误",
        "description": "react 开发中常见错误记录总结",
        "content": "## React 的常见初学者错误\n\n​\t这是我关注的一位前端开发者的分享，分享的非常棒！值得被更多人看到，原文英文版本，我做了翻译，希望对 React 开发者有所帮助。\n\n​\t在我最近开发的时候，在遇到复杂状态管理和副作用的时候，就会经常不能完全想到所有可能发生的情况，导致一些莫名其妙的 bug，如果你也是，那看完吧，一定有新的收获。以下是正文部分：\n\n“几年前，我在当地的一个编码训练营教 React，我注意到有一些事情让学生措手不及。人们不断掉进同一个坑里！在本教程中，我们将探索 8 个最常见的陷阱。您将学习如何绕过它们，并希望能够避免很多挫败感。为了保持这篇博客文章轻松流畅，我们不会过多探讨这些陷阱背后的原因。这更像是一个快速参考。下面看下常见的问题吧！\n\n> ##### 目标受众\n>\n> 这篇文章是为那些对React基础知识已经有所了解，但在他们的学习旅程中仍然处于初级阶段的开发者编写的。\n\n### 1. 使用 0 作为判断依据\n\n​\t好的，我们从其中一个最普遍的陷阱开始。我在一些生产应用程序中实际遇到过这个问题！\n\n​\t请看下以下代码：\n\n```js\n// react app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\n\nfunction App() {\n  const [items, setItems] = React.useState([]);\n  \n  return (\n    <div>\n      {items.length && <ShoppingList items={items} />}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <>\n      <h1>Shopping List</h1>\n      <ul>\n        {items.map((item, index) => {\n          // NOTE: We shouldn't use “index” as the key!\n          // This is covered later in this post \uD83D\uDE04\n          return (\n            <li key={index}>\n              {item}\n            </li>\n          );\n        })}\n      </ul>\n    </>\n  );\n}\n\nexport default ShoppingList\n```\n\n​\t我们的目标是有条件地显示一个购物清单。如果数组中至少有1个项目，我们应该渲染一个ShoppingList元素。否则，我们不应该渲染任何内容。**然而，我们最终在 UI 中得到一个随机的 `0` ！**\n\n​\t发生这种情况是因为 `items.length` 的计算结果为 `0` 。由于 0 在 JavaScript 中是一个虚假值，因此 `&&` 运算符短路，整个表达式解析为 `0` 。实际上，就好像我们这样做了一样：\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      {0}\n    </div>\n  );\n}\n```\n\n​\t与其他假值（如''、null、false等）不同，数字0是JSX中的一个有效值。毕竟，在许多情况下，我们确实希望打印数字0！\n\n**如何修复：** 我们的表达式应该使用一个“纯粹”的布尔值（true/false）：\n\n```jsx\nfunction App() {\n  const [items, setItems] = React.useState([]);\nreturn (\n    <div>\n      {items.length > 0 && (\n        <ShoppingList items={items} />\n      )}\n    </div>\n  );\n}\n```\n\n`items.length > 0` 将始终计算为 `true` 或 `false` ，因此我们永远不会有任何问题。或者，我们可以使用三元表达式：\n\n```jsx\nfunction App() {\n  const [items, setItems] = React.useState([]);\nreturn (\n    <div>\n      {items.length\n        ? <ShoppingList items={items} />\n        : null}\n    </div>\n  );\n}\n```\n\n​\t这两种选择都是完全有效的，这取决于**个人品味**。\n\n### 2. 不正确使用状态\n\n​\t让我们继续使用我们的购物清单示例。假设我们能够添加新项目：\n\n```js\n// app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\nimport NewItemForm from './NewItemForm';\n\nfunction App() {\n  const [items, setItems] = React.useState([\n    'apple',\n    'banana',\n  ]);\n  \n  function handleAddItem(value) {\n    items.push(value);\n    setItems(items);\n  }\n  \n  return (\n    <div>\n      {items.length > 0 && <ShoppingList items={items} />}\n      <NewItemForm handleAddItem={handleAddItem} />\n    </div>\n  )\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <>\n      <h1>Shopping List</h1>\n      <ul>\n        {items.map((item, index) => {\n          // NOTE: We shouldn't use “index” as the key!\n          // This is covered later in this post \uD83D\uDE04\n          return (\n            <li key={index}>\n              {item}\n            </li>\n          );\n        })}\n      </ul>\n    </>\n  );\n}\n\nexport default ShoppingList;\n```\n\n```js\n// NewItemFrom.js\nimport React from 'react';\n\nfunction NewItemForm({ handleAddItem }) {\n  const [value, setValue] = React.useState('');\n  \n  return (\n    <form\n      onSubmit={(event) => {\n        event.preventDefault();\n        \n        handleAddItem(value);\n        setValue('');\n      }}\n    >\n      {/* We'll touch on this ID stuff later too! */}\n      <label htmlFor=\"new-item-input\">\n        Item:\n      </label>\n      <input\n        value={value}\n        onChange={event => setValue(event.target.value)}\n      />\n      <button>\n        Add Item\n      </button>\n    </form>\n  );\n}\n\nexport default NewItemForm;\n```\n\n可看到如下：\n\n![image-20230623130414761](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623130414761.png)\n\n​\t每当用户提交一个新项目时，`handleAddItem`函数会被调用。不幸的是，它目前无法正常工作！当我们输入一个项目并提交表单时，该项目并没有被添加到购物清单中。\n\n**问题**出在我们违反了React中可能是最重要的规则之一：我们修改了**状态**的值。具体来说，问题是这一行：\n\n```jsx\n// app.js\nfunction handleAddItem(value) {\n  items.push(value);\n  setItems(items);\n}\n```\n\n​\tReact 依靠**状态变量的身份**（也就是这里的 useState hooks）来判断状态何时发生了变化。当我们把一个项目推到数组中时，我们不会改变该数组的身份，所以 React 无法判断这个值已经改变。\n\n**如何修复：** 我们需要创建一个全新的数组。以下是我的做法：\n\n```jsx\n// app.js\nfunction handleAddItem(value) {\n  const nextItems = [...items, value]; // 不知道有人看过我之前的文章不，这里也是遵守 react 的不可变性原则\n  setItems(nextItems);\n}\n```\n\n​\t与其修改现有的数组，我选择从头开始创建一个新的数组。这个新数组包含了与原数组完全相同的所有项（借助展开语法...），以及新添加的项。这里的区别在于**修改现有项**与**创建新项**之间的差异。当我们将一个值传递给像 setCount 这样的**状态设置函数**时，它需要是一个**新的实体**。**对象也是如此：**\n\n```js\n// ❌ Mutates an existing object\nfunction handleChangeEmail(nextEmail) {\n  user.email = nextEmail;\n  setUser(user);\n}\n// ✅ Creates a new object\nfunction handleChangeEmail(email) {\n  const nextUser = { ...user, email: nextEmail };\n  setUser(nextUser);\n}\n```\n\n​\t基本上，... 语法是一种将数组/对象中的所有内容复制/粘贴到全新实体中的方式。这确保一切正常运作。\n\n### 3. 不生成密钥\n\n以下是您之前可能看到的警告：\n\n> Warning: Each child in a list should have a unique \"key\" prop.\n>\n> 警告：列表中的每个子元素应该有一个唯一的 \"key\" 属性。\n\n最常见的情况是在对数据进行映射时发生此错误。以下是一个违反此规则的示例：\n\n```js\n// app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\nimport NewItemForm from './NewItemForm';\n\nfunction App() {\n  const [items, setItems] = React.useState([\n    'apple',\n    'banana',\n    'carrot',\n  ]);\n  \n  function handleAddItem(value) {\n    const nextItems = [...items, value]\n    setItems(nextItems);\n  }\n  \n  return (\n    <div>\n      {items.length > 0 && <ShoppingList items={items} />}\n      <NewItemForm handleAddItem={handleAddItem} />\n    </div>\n  )\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item) => {\n        return (\n          <li>{item}</li>\n        );\n      })}\n    </ul>\n  );\n}\n\nexport default ShoppingList;\n```\n\n```js\n// NewItemForm.js\nimport React from 'react';\nfunction NewItemForm({ handleAddItem }) {\n  const [value, setValue] = React.useState('');\n  \n  return (\n    <form\n      onSubmit={(event) => {\n        event.preventDefault();\n        \n        handleAddItem(value);\n        setValue('');\n      }}\n    >\n      {/* We'll touch on this ID stuff later too! */}\n      <label htmlFor=\"new-item-input\">\n        Item:\n      </label>\n      <input\n        value={value}\n        onChange={event => setValue(event.target.value)}\n      />\n      <button>\n        Add Item\n      </button>\n    </form>\n  );\n}\n\nexport default NewItemForm;\n```\n\n你会看到：\n\n![image-20230623132957917](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623132957917.png)\n\n​\t每当我们渲染一个元素数组时，我们需要为 React 提供额外的上下文信息，以便它能够识别每个项。关键是，这个标识符需要是唯一的。许多在线资源会建议使用数组索引来解决这个问题：\n\n```js\n// ShoppingList.js\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => {\n        return (\n          <li key={index}>{item}</li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\n​\t我不认为这是一个好的建议。这种方法有时可以工作，但在其他情况下可能会引发一些严重的问题。随着对 React 工作原理的更深入理解，您将能够在每个具体情况下判断是否可以使用这种方法，但老实说，我认为以一种始终安全的方式解决问题会更容易。这样，您就不必担心它！\n\n**下面是计划：** 每当向列表中添加新项时，我们将为其生成一个唯一的ID：\n\n```js\n// app.js\nfunction handleAddItem(value) {\n  const nextItem = {\n    id: crypto.randomUUID(),\n    label: value,\n  };\n  const nextItems = [...items, nextItem];\n  setItems(nextItems);\n}\n```\n\n`crypto.randomUUID `是内置于浏览器中的方法（它不是第三方包）。它在所有主要浏览器中都可用。它与加密货币无关。该方法生成一个类似于 `d9bb3c4c-0459-48b9-a94c-7ca3963f7bd0` 的唯一字符串。通过在用户提交表单时动态生成一个 ID，我们确保购物清单中的每个项都具有唯一的 ID。以下是如何将其应用为键的方法：\n\n```js\n// ShoppingList.js\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => {\n        return (\n          <li key={item.id}>\n            {item.label}\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\n重要的是，我们希望在状态更新时生成ID，而不是这样做：\n\n```jsx\n// ❌ This is a bad idea\n<li key={crypto.randomUUID()}>\n  {item.label}\n</li>\n```\n\n在 JSX 中这样生成会导致键在**每次渲染时发生变化**。当键发生变化时，React将销毁并重新创建这些元素，这可能对**性能产生重大负面影响**。这种模式——在创建数据时生成键——可以应用于各种情况。例如，下面是我在从服务器获取数据时创建唯一ID的方式：\n\n```js\nconst [data, setData] = React.useState(null);\nasync function retrieveData() {\n  const res = await fetch('/api/data');\n  const json = await res.json();\n  // The moment we have the data, we generate\n  // an ID for each item:\n  const dataWithId = json.data.map(item => {\n    return {\n      ...item,\n      id: crypto.randomUUID(),\n    };\n  });\n  // Then we update the state with\n  // this augmented data:\n  setData(dataWithId);\n}\n```\n\n### 4. 缺少空格\n\n这是我在网络上经常看到的一个非常让人困惑的问题。\n\n```js\nimport React from 'react';\n\nfunction App() {\n  return (\n    <p>\n      Welcome to Corpitech.com!\n      <a href=\"/login\">Log in to continue</a>\n    </p>\n  );\n}\n\nexport default App;\n```\n\n你会看到：![image-20230623133756836](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623133756836.png)\n\n注意到这两个句子被混在一起了：\n\n![image-20230623133859746](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623133859746.png)\n\n这是因为 **JSX 编译器**（将我们编写的 JSX 转换为适用于浏览器的 JavaScript 的工具）**无法真正区分语法上的空格和我们为缩进/代码可读性而添加的空格**。\n\n**如何修复它：** 我们需要在文本和锚点标记之间添加一个**显式的空格字符**：\n\n```jsx\n<p>\n  Welcome to Corpitech.com!\n  {' '}\n  <a href=\"/login\">Log in to continue</a>\n</p>\n```\n\n一个小小的专业技巧：如果您使用 `Prettier`，它会自动为您添加这些空格字符！只需确保让它进行格式化（不要提前将内容拆分为多行）。\n\n> 为什么 React 团队没有解决这个问题？\n>\n> 当我第一次了解到这种策略时，我也觉得有些凌乱。为什么 React 团队不能修复它，使其按照我们的预期工作呢？！我后来意识到这个问题并没有完美的解决方案。如果 React 开始将缩进解释为语法上的空格，可以解决这个问题，但也会引入一系列其他问题。最终，尽管它看起来有些笨拙，但我认为这是正确的决定。这是最不糟糕的选择！\n\n### 5. 在修改状态后访问它\n\n​\t这个问题在某个时刻都会让人措手不及。在我在一家本地编程训练营教授时，我已经记不清有多少次有人因为这个问题向我求助了。下面是一个最简单的计数器应用程序：点击按钮会增加计数。看看你能否发现问题所在：\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [count, setCount] = React.useState(0);\n  \n  function handleClick() {\n    setCount(count + 1);\n    \n    console.log({ count });\n  }\n  \n  return (\n    <button onClick={handleClick}>\n      {count}\n    </button>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623134419724](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623134419724.png)\n\n在增加计数状态变量后，我们将其值记录到控制台。令人奇怪的是，它记录了错误的值：\n\n![image-20230623134525645](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623134525645.png)\n\n问题出在这里：React 中的状态设置函数（例如 setCount）是异步的。\n这是有问题的代码是这里：\n\n```js\nfunction handleClick() {\n  setCount(count + 1);\n  console.log({ count });\n}\n```\n\n很容易错误地认为 setCount 函数类似于赋值，好像这样做是等同于这样的操作：\n\n```js\ncount = count + 1;\nconsole.log({ count });\n```\n\n​\t然而，React 并不是这样构建的。当我们调用 setCount 时，我们并没有重新赋值给一个变量，而是安排了一个更新操作。\n\n​\t对于我们完全理解这个概念可能需要一些时间，但下面的解释或许有助于更好地理解：我们无法重新赋值给 count 变量，因为它是一个常量！\n\n```js\n// Uses `const`, not `let`, and so it can't be reassigned\nconst [count, setCount] = React.useState(0);\ncount = count + 1; // Uncaught TypeError:\n                   // Assignment to constant variable\n```\n\n那么我们应该如何修复这个问题呢？幸运的是，我们已经知道这个值应该是什么。我们需要将它存储在一个变量中，以便我们可以访问它：\n\n```js\nfunction handleClick() { // 再次验证不可变性重要性，使用新的变量记录最新的状态\n  const nextCount = count + 1;\n  setCount(nextCount);\n  // Use `nextCount` whenever we want\n  // to reference the new value:\n  console.log({ nextCount });\n}\n```\n\n​\t我喜欢在这种情况下使用“next”前缀（比如nextCount、nextItems、nextEmail等）。这样对我来说更清晰，我们不是更新当前值，而是安排下一个值。\n\n### 6. 返回多个元素\n\n​\t有时，一个组件需要返回多个顶级元素。例如：\n\n```js\n// app.js\nimport React from 'react';\nimport LabeledInput from './LabeledInput';\n\nfunction App() {\n  const [name, setName] = React.useState('');\n  \n  return (\n    <LabeledInput\n      id=\"name\"\n      label=\"Your name\"\n      value={name}\n      onChange={(event) => setName(event.target.value)}\n    />\n  );\n}\n\nexport default App;\n```\n\n```js\n// LabeledInput.js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <label htmlFor={id}>\n      {label}\n    </label>\n    <input\n      id={id}\n      {...delegated}\n    />\n  );\n}\n\nexport default LabeledInput;\n```\n\n你会看到：\n\n![image-20230623135153465](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623135153465.png)\n\n我们希望我们的 LabeledInput 组件返回两个元素：一个 `<label>` 和一个 `<input>`。令人沮丧的是，我们遇到了一个错误：\n\n![image-20230623135238318](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623135238318.png)\n\n这是因为 JSX 编译为普通的 JavaScript。下面是在浏览器中运行时这段代码的样子：\n\n```js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    React.createElement('label', { htmlFor: id }, label)\n    React.createElement('input', { id: id, ...delegated })\n  );\n}\n```\n\n在 JavaScript 中，我们不能像这样返回多个值。这也是为什么这种写法不起作用的原因：\n\n```js\nfunction addTwoNumbers(a, b) {\n  return (\n    \"the answer is\"\n    a + b\n  );\n}\n```\n\n我们该如何修复呢？很长一段时间以来，标准做法是将这两个元素包装在一个包裹标签中，比如 `<div>`：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <div>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </div>\n  );\n}\n```\n\n通过将 `<label>` 和 `<input>` 包装在 `<div>` 中，我们只返回一个顶层元素！以下是它在普通的 JavaScript 中的样子：\n\n```js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return React.createElement(\n    'div',\n    {},\n    React.createElement('label', { htmlFor: id }, label),\n    React.createElement('input', { id: id, ...delegated })\n  );\n}\n```\n\n​\tJSX 是一个很棒的抽象，但它常常会掩盖关于 JavaScript 的基本真理。我认为，查看 JSX 如何转换为普通的 JavaScript，以了解实际发生的情况往往是有帮助的。通过这种新的方法，我们返回一个单独的元素，而该元素包含两个子元素。问题解决了！但我们可以使用片段（fragments）进一步改进这个解决方案：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <React.Fragment>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </React.Fragment>\n  );\n}\n```\n\n​\t`React.Fragment`是一个专门用来解决这个问题的React组件。它允许我们将多个顶级元素捆绑在一起，而不会影响DOM。这非常棒：这意味着我们不会在标记中加入不必要的`<div>`。它还有一个便捷的简写方式，我们可以像这样编写片段：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </>\n  );\n}\n```\n\n我喜欢这里的符号意义：React团队选择使用一个空的HTML标签`<>`来表示片段不会产生任何实际的标记。\n\n### 7. 从不受控制变为受控制状态\n\n让我们来看一个典型的表单示例，将一个输入与React状态绑定起来：\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [email, setEmail] = React.useState();\n  \n  return (\n    <form>\n      <label htmlFor=\"email-input\">\n        Email address\n      </label>\n      <input\n        id=\"email-input\"\n        type=\"email\"\n        value={email}\n        onChange={event => setEmail(event.target.value)}\n      />\n    </form>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623140328986](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140328986.png)\n\n如果你在这个输入框中开始输入，你会注意到控制台上会出现一个警告：\n\n![image-20230623140357471](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140357471.png)\n\n解决方法如下：我们需要将 `email` 状态初始化为空字符串：\n\n```js\nconst [email, setEmail] = React.useState('');\n```\n\n​\t当我们设置value属性时，我们告诉 React 我们希望这是一个受控输入框。但是，这只有在我们传递一个定义的值时才起作用！通过将email初始化为空字符串，**我们确保 value 永远不会被设置为undefined**。\n\n> 受控输入\n>\n> 如果您想详细了解为什么这是必要的，以及什么是“受控输入”，我们将在我最近发布的教程中深入探讨这些想法：[React中的数据绑定](https://www.joshwcomeau.com/react/data-binding/)\n\n​\tJSX 被设计得看起来很像 HTML，但它们之间有一些令人惊讶的差异，往往会让人措手不及。大多数差异都有很好的文档记录，而且控制台的警告通常非常具体和有帮助。例如，如果你意外使用 class 而不是className，React会准确告诉你问题所在。但有一个微妙的差异经常让人困惑：style属性。在HTML中，style是以字符串的形式表示的：\n\n```html\n<button style=\"color: red; font-size: 1.25rem\">\n  Hello World\n</button>\n```\n\n但是，在 JSX 中，我们需要将其指定为一个对象，并带有驼峰属性名称。在下面的代码中，我试图做到这一点，但出现了错误。你能找出错误吗？\n\n```js\nimport React from 'react';\n\nfunction App() {\n  return (\n    <button\n      style={ color: 'red', fontSize: '1.25rem' }\n    >\n      Hello World\n    </button>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623140901535](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140901535.png)\n\n问题是我需要使用**双波浪线**，如下所示：\n\n```js\n<button\n  // \"{{\", instead of \"{\":\n  style={{ color: 'red', fontSize: '1.25rem' }}\n>\n  Hello World\n</button>\n```\n\n为了理解为什么这样是必要的，我们需要稍微了解一下这个语法。在JSX中，我们使用花括号来创建一个表达式插槽。我们可以在这个插槽中放置任何有效的JavaScript表达式。例如：\n\n```jsx\n<button className={isPrimary ? 'btn primary' : 'btn'}>\n```\n\n无论我们在{}中放置什么，都将被视为JavaScript进行求值，并将结果设置为该属性的值。className将是'btn primary'或'btn'。对于style，我们首先需要创建一个表达式插槽，然后将一个JavaScript对象传递到这个插槽中。我认为如果我们将对象提取到一个变量中，会更清晰明了：\n\n```js\n// 1. Create the style object:\nconst btnStyles = { color: 'red', fontSize: '1.25rem' };\n// 2. Pass that object to the `style` attribute:\n<button style={btnStyles}>\n  Hello World\n</button>\n// Or, we can do it all in 1 step:\n<button style={{ color: 'red', fontSize: '1.25rem' }}>\n```\n\n外层的花括号创建了JSX中的\"表达式插槽\"。内层的花括号创建了一个JavaScript对象，用于保存我们的样式。\n\n### 8. 异步的 effect 函数\n\n​\t假设我们有一个函数，在挂载时从 API 中获取一些用户数据。我们将使用 useEffect 钩子，并希望使用 await 关键字。以下是我第一次尝试的代码：\n\n```js\n// app.js\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  return (\n    <UserProfile userId=\"abc123\" />\n  );\n}\n\nexport default App;\n```\n\n```js\n// UserProfile.js\nimport React from 'react';\nimport { API } from './constants';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = React.useState(null);\n  \n  React.useEffect(() => {\n    const url = `${API}/get-profile?id=${userId}`;\n    const res = await fetch(url);\n    const json = await res.json();\n    \n    setUser(json.user);\n  }, [userId]);\n  \n  if (!user) {\n    return 'Loading…';\n  }\n  \n  return (\n    <section>\n      <dl>\n        <dt>Name</dt>\n        <dd>{user.name}</dd>\n        <dt>Email</dt>\n        <dd>{user.email}</dd>\n      </dl>\n    </section>\n  );\n}\n\nexport default UserProfile;\n```\n\n```js\n// constants.js\nexport const API = 'https://jor-test-api.vercel.app/api';\n```\n\n你会看到：\n\n![image-20230623141348771](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623141348771.png)\n\n不幸的是，我们收到一个错误：\n\n![image-20230623141402587](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623141402587.png)\n\n**这是修正的方法：**我们需要在 effect 中创建一个单独的异步函数：\n\n```js\nReact.useEffect(() => {\n  // Create an async function...\n  async function runEffect() {\n    const url = `${API}/get-profile?id=${userId}`;\n    const res = await fetch(url);\n    const json = await res.json();\n    setUser(json);\n  }\n  // ...and then invoke it:\n  runEffect();\n}, [userId]);\n```\n\n为了理解为什么需要这个变通方法，值得考虑一下 async 关键字的实际作用。例如，你会猜测下面这个函数返回什么？\n\n```js\nasync function greeting() {\n  return \"Hello world!\";\n}\n```\n\n乍一看，似乎很明显：它返回字符串` \"Hello world!\"`！但实际上，这个函数返回一个 Promise。这个 Promise 解析为字符串 `\"Hello world!\"`。这是一个问题，因为 useEffect 钩子并不期望我们返回一个 Promise！它期望我们返回无值（就像我们上面的示例中所做的），或者返回一个清除函数。清除函数远超出了本教程的范围，但它们非常重要。大多数的 effect 都会有一些拆除逻辑，我们需要尽快将其提供给 React，这样 React 就可以在**依赖项更改或组件卸载时**调用它。 通过使用\"单独的异步函数\"策略，我们仍然可以立即返回一个清除函数：\n\n```js\nReact.useEffect(() => {\n  async function runEffect() {\n    // Effect logic here\n  }\n  runEffect();\n  return () => {\n    // Cleanup logic here\n  }\n}, [userId]);\n```\n\n你可以将这个函数命名为任何你喜欢的名称，但我喜欢使用通用名称 runEffect。它清晰地表明它包含了主要的 effect 逻辑。\n\n### 9. 培养直觉 （经验）\n\n​\t一开始，我们在这个教程中看到的很多修复方法似乎相当随意。为什么我们需要提供一个唯一的键（key）？为什么我们无法在改变状态后访问它？为什么useEffect如此棘手？React一直以来都相当棘手，尤其是现在使用hooks时更是如此。需要一段时间才能理解一切。我在2015年开始使用React，还记得当时想：“这玩意太酷了，但我完全不知道它是如何工作的。” \uD83D\uDE05从那时起，我逐渐构建了自己关于React的思维模型，一块一块地拼凑。我经历了一系列的顿悟，每一次顿悟都使我的思维模型更加坚实、更加完善。我开始理解React为什么会以这种方式工作。我发现自己不必记住任意的规则；相反，我可以依靠自己的直觉。很难言喻 React 对我来说变得更加有趣了！在过去的一年里，我一直在开发一门名为《React的乐趣》的交互式自学在线课程。这是一门面向初学者的课程，旨在帮助你建立对React工作原理的直觉，以便用它构建丰富、动态的Web应用程序。我的课程与其他课程不同；你不会坐在那里看我连续几个小时地编码。《React的乐趣》结合了许多不同的媒体形式：视频、交互式文章、挑战性练习、以真实世界为灵感的项目，甚至还有一两个小游戏。《React的乐趣》将在几个月内发布。你可以在课程主页上了解更多信息，并注册接收更新：[《react的乐趣》](https://www.joyofreact.com/)\n\n”\tEND\n\n​\t我想补充两个我最近开发遇到的问题，\n\n1. 第一个就是 useState 的异步问题，当我们setState后如果立刻取值 state 得到的可能不是最新的值，这真的很坑人，\n2. 第二个是 在React 中，如果想要立刻获取到最新的值，你可以使用 useRef 进行同步，但是它不能更新UI视图，所以一定要记得使用 state 去触发页面 UI 更新，\n3. 当面临列表数据，并且页面渲染复杂时候，一定要记得给组件使用 React.memo 包裹，当props更新的时候才重新渲染页面，这样就能避免不必要的刷新\n\n​\t文章很长，需要花10~15分钟才能看完，认真看完的同学，你真的好厉害，也希望你在 React 的开发者寻找到自己的最佳实践\n\n\n\n原文链接： [常见的React初学者错误](https://www.joshwcomeau.com/react/common-beginner-mistakes/)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/qLeUiada-Snipaste_2023-06-23_14-45-25.png",
        "language": null,
        "viewNum": 22,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-23T06:46:33.000+00:00",
        "updateTime": "2023-06-26T17:04:12.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-06-27T06:23:53.000+00:00"
        },
        "tags": [
          "文章",
          "React",
          "笔记",
          "经验分享"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1671706615327285249",
        "title": "专科大三-Go-实习/秋招",
        "description": null,
        "content": "鱼皮哥您好，我想向您咨询一些简历相关的问题\n### 个人情况\n本人专科大三准备毕业开始要找工作了，这段时间也一直在用 Go 重写你的项目，现在写的差不多了，简历也写出来第一版了，鱼皮哥可以帮我看一下简历有哪些地方不足要修改的地方吗，对于两个项目都还没有上线，域名还在备案，估计这几天就下来了，到时候可以部署上线\n### 提问\n我想问一下面试的时候这个项目是说用go重写的还是自己写的，我怕说自己写的，前端那方面有些地方答不上来\n### 简历\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1609234177662648321/YkQU9IJm-a01c29dea3aed9d005f2c034b0403fa.png",
        "language": null,
        "viewNum": 30,
        "thumbNum": 0,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1609234177662648321",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-22T02:28:10.000+00:00",
        "updateTime": "2023-06-27T06:58:42.000+00:00",
        "user": {
          "id": "1609234177662648321",
          "planetCode": "3665",
          "userName": "helloworg",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1609234177662648321/q7qoH4jk-331622120_235617872144916_5453336620106197415_n.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T22:35:31.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-31T17:05:00.000+00:00",
          "updateTime": "2023-06-22T02:16:41.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1671131561837211650",
        "title": "上线啦！",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/bo2j3Tim-640.jpg",
        "language": null,
        "viewNum": 150,
        "thumbNum": 6,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-20T12:23:07.000+00:00",
        "updateTime": "2023-06-27T07:27:00.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1685,
          "coin": 170,
          "followeeNum": 838,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-06-27T05:59:46.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": [],
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      },
      {
        "id": "1670012971482361858",
        "title": "前端一年半，半年总结",
        "description": "一个努力生活，努力工作的前端开发工程师的半年总结",
        "content": "## 我也想成为 不高兴就喝水口 中的前 10%\n\n ![image-20230617165418569](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617165418569.png)\n\n​\t从我的老板和水哥的聊天中，水哥说了一个很接地气的理论，如果能够成为行业的前 10% ，一定不会太差。我是很认同的，确实不能再每天都当 NPC ，随波逐流了，那行业前10%前提怎么实现呢？从我现在来看我觉得是非常难的，原因有：\n\n1. 我目前的学历和能力都很普通，没有在大厂工作的经历\n2. 社会压力很大，人们都在奋斗，互联网行业也不再像之前那样充满活力\n3. 我常常会被短暂的激情所驱使，情绪容易波动，难以保持专注\n4. 不可否认，现在有很多诱惑，比如抖音等社交媒体，总是把我时间偷走\n5. 也没有什么抱负，没有很强的事业心那种，希望自己能够把生活过的不错就满意了\n\n。。。 总之 ，我就是一个知道很多，但是缺少行动力的人，但是，我身边人都很优秀啊，环境对绝大多数的人的影响都是很大的，我这样认为，我有一个不能再优秀的老板，有每天都打鸡血似的小 y，还有太多优秀的人被我看见，希望自己能平视这些优秀的伙伴，看了很多道理，听了很多故事，我想我需要规划一下自己，彻底的，客观的直视自己，总结一下上半年，规划一下 下半年 和 自己的未来，总不能一直被推着走，\n\n​\t![image-20230617165753688](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617165753688.png)\n\n​\t这是我在年初定的目标，其实是完全没有做到的，但是这半年我也有改变，找到了真正喜欢的工作，真的很幸运，也让我更加相信行动的重要性，我只需要努力去做，结果交给时间。\n\n​\t在上半年，我有段时间是在每天学习的，每天写新的技术笔记，很不幸，和每次都一样，没能坚持，也让我更加坚信，行动是需要动力的，生活是需要鼓励和鸡汤的，\n\n![image-20230617170334695](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617170334695.png)\n\n​\t这是我的 github 近期，语雀也差不多，我考了驾照，成功找到梦想工作，学习了新的技术，做了自己的简单的博客系统，但是还有很多功能需要添加，现在还不能上线，学习了很多技术，也做了自己的技术栈总结，了解自己会哪些，哪些需要系统学习，补充。也有思考过自己的工作和生活的平衡点，还在慢慢探索属于自己的高效工作，快乐生活的方法。\n\n​\t对于 2023 的上半年，我其实摆烂了，没有达到年初的 flag，但是 2023 还在继续，我会在下半年加油⛽️，努力把 flag 都变成现实，我觉得无论是摆烂还是积极努力，都是最好的我，都是为了更好的整理好继续前进。如果你觉得我说的对，那给我点个赞可以吗，这对我真的很重要\n\n​\t进入 2023 年下半年，我将全力以赴工作和生活，减少懒散，多做有意义的事情。以下是我的具体目标：\n\n1. 深入学习React源码，提升技术水平，增强解决问题的能力和从容应对的能力\n2. 写文章，**每周**至少一偏纯技术学习笔记，学习并记录下来，希望通过分享简单易懂的文字，提高自己的写作能力，编程能力和思维能力\n3. **每周**至少运动一次，跑步，羽毛球等等，健康和钱 ，我全都要 \uD83D\uDC36\n4. 努力工作，认真工作，让自己成为一个成熟的打工人，不拖后腿，如果能产生更多价值，那就更好了\n5. 快乐生活，简单大方，希望自己能够落落大方，对待任何事情和人，提高自己情绪的稳定性\n6. 希望能够找到一个合适的伴侣。\n7. 希望自己能开启自己的自媒体的路，其实我也很喜欢分享和开源，所以记录下我的成长不会是我的负担，\n8. 做自己的博客网站，并开源，并写详细的实现过程，做一个自己的原创项目\n9. 我有两个榜样，一个是冴羽，一个是鱼皮，希望能从他们身上学到更多，并将其转化为自己的收获。\n\n​\t这里，我分享一下 冴羽 的微信付费文章，真的不错，是我 2023 前五的对自己的投资，从如何建立信念，培养自尊，刺激去行动，如何更好的去行动，如何寻找目标，如何更好的管理自己的精力，到近期的如何更好的管理自己，每一篇都是精华，给大家看下我的阅读笔记\n\n![image-20230617173923681](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617173923681.png)\n\n​\t\n\n​\t最后，我自身总结发现，如果想要去做一件事情并且坚持下来，是需要自己给自己的行为赋予意义的，也可以说是自己给自己画饼，只有自己和这个目标产生吸引力，才能产生动力，才能产生行为，才能产生结果。至于是什么结果，我觉得应该不会太差。这也是我最近学习到的 吸引力法则，动力本身就应该源于自己，不是源于我自己的动力产生的行为，在我身上都没有坚持下来，不知道大家是不是这样。\n\n​\t半年总结活动还在进行，希望看到更多人对自己的思考，并分享出来，写下来，大家互相学习，一起进步。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/eXtBPogO-快乐的小狗.png",
        "language": null,
        "viewNum": 91,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-17T10:18:14.000+00:00",
        "updateTime": "2023-06-27T07:18:50.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-06-27T06:23:53.000+00:00"
        },
        "tags": [
          "文章",
          "交流社区",
          "自我介绍",
          "前端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1668836124593762306",
        "title": "深入浅出——InnoDB记录结构详解，菜鸡看了直呼：能懂！",
        "description": "从这篇文章开始，将对InnoDB的行格式和页结构进行介绍，这里主要介绍一下InnoDB的行格式，但是在故事的开始，都来提一下吧 **InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB**。这样的话，一次性至少读取1页数据到内存中或者将1页数据写入磁盘。通过减少内存与磁盘的交互次数，从而提升性能。",
        "content": "从这篇文章开始，将对InnoDB的行格式和页结构进行介绍，这里主要介绍一下InnoDB的行格式，但是在故事的开始，都来提一下吧\n**InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB**。这样的话，一次性至少读取1页数据到内存中或者将1页数据写入磁盘。通过减少内存与磁盘的交互次数，从而提升性能。\n\n 这一种典型的缓存设计思想，一般缓存的设计基本都是从时间维度或者空间维度进行考量的：\n\n- 时间维度：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。\n\n- 空间维度：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。\n\n  ![image-20230613140903458](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613140903458.png)\n\n# 行格式\n\nMySQL是以记录(一行数据)为单位向数据表中插入数据的，这些记录在磁盘上的存放方式称为行格式。\n\nMySQL支持的4种行格式\n\n- Compact\n- Redundant（比较老，本文就不具体介绍了）\n- Dynamic\n- Compressed\n\n**指定行格式**\n\n```mysql\nCREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称\nALTER TABLE 表名 ROW_FORMAT=行格式名称\n```\n\n**下面来说一说各个行格式的区别**\n\n## **COMPACT行格式**\n\n![image-20230613142254381](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613142254381.png)\n\n> // (-_- ^!^) 这怎么这么像协议，hhh\n\n咱们就不从大类上来说了，直接从小抓起\n\n### 记录的额外信息\n\n在将之前，:mouse::mouse:在这里做个预处理，咱们假设有一张表，长这个屌样\n\n```mysql\nmysql> CREATE TABLE record_format_demo (\n    ->     c1 VARCHAR(10),\n    ->     c2 VARCHAR(10) NOT NULL,\n    ->     c3 CHAR(10),\n    ->     c4 VARCHAR(10)\n    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;\nQuery OK, 0 rows affected (0.03 sec)\n-------------------------------------------------------------\nmysql> SELECT * FROM record_format_demo;\n+------+-----+------+------+\n| c1   | c2  | c3   | c4   |\n+------+-----+------+------+\n| aaaa | bbb | cc   | d    |\n| eeee | fff | NULL | NULL |\n+------+-----+------+------+\n2 rows in set (0.00 sec)\n```\n\n#### **变长字段长度列表**\n\n对于VARCHAR(M)、TEXT等变长数据类型，存储数据占用的存储空间不是固定的，而是会随着存储内容的变化而变化。\n所以至少得包含以下内容\n\n- 真正的数据内容\n- 占用的字节数\n\n在Compact行格式中，把所有变长字段的真实数据**占用的字节长度**都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数==按照列的顺序逆序存放==。\n\n>**变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的**\n>\n>![image-20230613142045172](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613142045172.png)\n\n#### NULL值列表\n\n对于可为NULL的列，为了节约存储空间，MySQL不会将NULL值保存在记录的真实数据部分。而是会将其保存在记录的额外信息里面的NULL值列表中。\n\n先统计表中允许存储NULL值的列，然后将**每个允许存储NULL值的列**对应**一个二进制位**（1：值为NULL，0：值不为NULL）用来表示是否存储NULL值，并**按照逆序排列**。\n\n> :tipping_hand_man:: MySQL规定**NULL值列表必须用整数个字节的位表示**，如果使用的二进制位个数不是整数个字节，则在字节的高位补0\n\nemmm... 这里来个例子看看比较好（图片都懒得做，网上有现成的我直接用了 qwq）\n\n数据咱们上面说了，对应record_format_demo表中，c1、c3、c4都是允许存储NULL值的。前两条记录在填充了NULL值列表后的示意图就是这样：\n\n![image-20230613142011240](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613142011240.png)\n\n> 这里:mouse::mouse:来:dog:叫一下：\n>\n> 06？不是二进制位吗？\n>\n> 首先，能为空的是134\n>\n> 为空的只有3 4\n>\n> 所以这是在表中其实是这样\n>\n> 1 3 4\n>\n> 0 1 1\n>\n> 但是要倒排序 所以是 110\n>\n> 然后不就是6吗，高位补零06\n>\n> 注意，这里使用十六进制表示\n\n#### 记录头信息\n\n记录头信息是由固定的5个字节(40位)组成, 不同的位代表不同的含义：\n\n![image-20230613141931147](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613141931147.png)\n\n下面对各个属性进行西索：\n\n![image-20230613141833415](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613141833415.png)\n\n> 具体的内容在后面我们西索\n>\n> 好奇的可以去嗦一口　[揭秘：行的记录头信息](#line_header)\n> 这里我放在页结构里面讲，具体为什么主要和页目录有一定关联，一起学比较好，hhh\n\n### **记录的真实数据**\n\n除去原有数据外，还有隐藏数据\n\n- ![image-20230613141606391](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613141606391.png)\n\n只有当数据库没有定义主键或者唯一键时，隐藏列row_id才会存在，并且将其作为数据表主键。因为表record_format_demo并没有定义主键，所以MySQL服务器会为每条记录增加上述的3个列。\n\n![image-20230613141538359](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613141538359.png)\n\n> 实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，为了美观才写成了row_id、transaction_id和roll_pointer。\n\n#### **CHAR(M)列的存储格式**\n\n对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而**如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表**。\n\n>**变长字符集**的CHAR(M)类型的列要求**至少**占用M个字节，而VARCHAR(M)却没有这个要求。比方说对于使用utf8字符集(一个字符占3个字节)的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节，即使我们向该列中存储一个空字符串也会占用10个字节。\n>\n>CHAR定长是对字符位数定长，但是字符集却不一定是定长的，下面来说一下定长字符集和变长字符集\n>\n>定长字符集 ascll\n>\n>变长字符集 utf-8/gbk等\n>\n>这就意味着：==对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。==\n\n## 行溢出数据\n\n这里我放到前面来说，趁热打铁\n\n### VARCHAR(M)最多能存储的数据\n\nMySQL对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外，**其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节**。(简单来说就是**普通的mysql一行记录占用的存储空间不能超过65535个字节**)\n\n当然，这65535里面还存储了其他数据（storage overhead）\n\n拿varchar来说，主要有3部分：\n\n- 真实数据\n- 真实数据占用字节的长度  2字节\n- NULL值标识，如果该列有NOT NULL属性则可以没有这部分存储空间 1字节\n\n假设varchar_size_demo只有一个VARCHAR类型的字段，如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据。如果该列是ascii字符集，对应的最大字符数最大为65532；如果是utf8字符集，则对应的最大字符数为21844。\n\n### 记录中的数据太多产生溢出\n\n再来个文章预处理，hhh\n\n```mysql\nmysql> CREATE TABLE varchar_size_demo(\n    ->       c VARCHAR(65532)\n    -> ) CHARSET=ascii ROW_FORMAT=Compact;\t\t\t#这里用的ascii编码\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));\t#插入一条记录\nQuery OK, 1 row affected (0.00 sec)\n```\n\n> REPEAT函数的作用是重复定义一个字符串n次\n\n上面也提到过**mysql中磁盘与内存交互的基本单位是页，一般为16KB，16384个字节**，而**一行记录最大可以占用65535个字节**，这就造成了**一页存不下一行数据的情况**。\n\n- 分页存储:dog:    # ( q _ q ^—^) 来了 神魔梦幻联动\n\n在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页\n\n![img](https://pic2.zhimg.com/80/v2-80d7f43f7a89ce5531545ce9a5c785b5_1440w.webp)\n\n这种**在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中的情况就叫做行溢出，存储超出768字节的那些页面也被称为溢出页**。\n\n![img](https://pic4.zhimg.com/80/v2-05454eebb3f499801fd62d376c66ab03_1440w.webp)\n\n>学到这里，再次感叹道四大基础的重要性啊，让我想到了os的分页存储，感兴趣的同学可以异步这里康康\n>\n>[操作系统-超20000字的“总结” – Karos (wzl1.top)](https://www.wzl1.top/2023/02/操作系统-超20000字的总结/)\n\n### 行溢出的临界点\n\n**MySQL中规定一个页中至少存放两行记录**。以上边的varchar_size_demo表为例，它只有一个列c，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会行溢出的现象呢？这得分析一下页中的空间都是如何利用的。\n\n1. 每个页除了存放我们的记录以外，也需要存储一些额外的信息，大概132个字节。\n\n2. 每个记录需要的额外信息是27字节\n\n   **这27个字节包括下边这些部分：**\n\n   - **2个字节用于存储真实数据的长度**\t（一行记录最大可以占用65535个字节）\n   - **1个字节用于存储列是否是NULL值**\n   - **5个字节大小的头信息**\n   - **6个字节的`row_id`列**\n   - **6个字节的`transaction_id`列**\n   - **7个字节的`roll_pointer`列**\n\n假设一个列中存储的数据字节数为n，如要要保证该列不发生溢出，则需要满足：\n\n```text\n132 + 2×(27 + n) < 16384\t#页的大小 16kb 16384字节\n```\n\n结果是n < 8099。**也就是说如果一个列中存储的数据小于8099个字节，那么该列就不会成为溢出列**。如果表中有多个列，那么这个值更小。\n\n>compact行格式这一块儿的内容部分参考于:\n>\n>- [mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/180531140)\n>- [Mysql\\]innodb记录compact行格式是什么样子的(笔记)_pmdream的博客-CSDN博客](https://blog.csdn.net/pmdream/article/details/106810867)\n\n## Redundant行格式\n\n有点太老了，上面引入的文章都没提过，嗯，这里还是提一下吧\n\n![image-20230613141459088](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613141459088.png)\n\n先把行格式改了\n\n```mysql\nmysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;\n-------------------------------------------------------------------\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\n```\n\n![image-20230613144522298](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613144522298.png)\n\n### 记录的额外信息\n\n#### 字段长度偏移表\n\n注意的是,compact存储的是变长字段长度,而这里存储的是**所有字段**长度**偏移**\n\n下面咱们从偏移这一块来西索:\n\n简单的概括：用两个相邻数值的插值来计算各个列值的长度\n\n![image-20230613145634802](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613145634802.png)\n\n#### 记录头信息\n\nRedundant 行格式的记录头信息占用 6 字节， 48 个二进制位，这些二进制位代表的意思如下：\n\n|      名称       | 大小（单位：bit） |                             描述                             |\n| :-------------: | :---------------: | :----------------------------------------------------------: |\n|     预留位1     |         1         |                           没有使用                           |\n|     预留位2     |         1         |                           没有使用                           |\n|   delete_mask   |         1         |                     标记该记录是否被删除                     |\n|  min_rec_mask   |         1         |        B+树的每层非叶子节点中的最小记录都会添加该标记        |\n|     n_owned     |         4         |                   表示当前记录拥有的记录数                   |\n|     heap_no     |        13         |                表示当前记录在页面堆的位置信息                |\n|     n_field     |        10         |                      表示记录中列的数量                      |\n| 1byte_offs_flag |         1         | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的 |\n|   next_record   |        16         |                   表示下一条记录的相对位置                   |\n\n### 记录的真实数据\n\n这里就不西索了\n\n## Dynamic和Compressed行格式\n\nDynamic行格式 是MySQL 5.7使用的默认行格式\n\n其实这他们和compact特别相似，但是在行数据溢出处理有些不同，就是在分页的时候，并不会存储前768个字节，会把前768个字节也存储到页面中\n\n![image-20230613150923452](http://gd.7n.cdn.wzl1.top/typora/img/image-20230613150923452.png)\n\n其中Compressed会使用压缩算法对页面进行压缩，以节省空间\n\n> 部分内容参考自：[MySQL 是怎样运行的：从根儿上理解 MySQL - 小孩子4919 - 掘金小册 (juejin.cn)](https://juejin.cn/book/6844733769996304392?enter_from=search_result&utm_source=search)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608208038794100737/xxLVGDLm-image-20230613142254381.png",
        "language": null,
        "viewNum": 39,
        "thumbNum": 3,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608208038794100737",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-14T04:21:52.000+00:00",
        "updateTime": "2023-06-26T07:56:50.000+00:00",
        "user": {
          "id": "1608208038794100737",
          "planetCode": "14757",
          "userName": "Karos",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1608208038794100737/n43g3wnh-QQ截图20230220091409.png",
          "gender": 1,
          "userProfile": "爱好 唱 跳 rap和篮球\uD83C\uDFC0",
          "userRole": "vip",
          "interests": [],
          "place": "四川",
          "birthday": "2003-02-11",
          "school": null,
          "major": "物联网工程",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": "嘉丽顿",
          "job": "后端",
          "workYear": -2,
          "direction": "后端",
          "goal": "实习",
          "github": "https://github.com/karosown",
          "blog": "https://www.wzl1.top/",
          "score": 10,
          "coin": 100,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-02T23:45:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-28T21:07:30.000+00:00",
          "updateTime": "2023-06-14T15:09:42.000+00:00"
        },
        "tags": [
          "文章",
          "MySQL"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1668550145291071489",
        "title": "面试SLG游戏项目开发值得去吗?",
        "description": null,
        "content": "刚刚约了一个面试，是一家20~99人的公司，要求是Java基础、HTTP、Servlet.Json、XML、Socket这些，还要熟悉SMARTFOXSERVER等基于NETTY的网络框架(这个不会)，还要有游戏开发经验(这一点也不符合)。主要是想问一下，SLG游戏项目开发值得去吗?希望有相关经验的同学能给指点一下，谢谢！",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 26,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1651091794630324226",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-13T09:25:29.000+00:00",
        "updateTime": "2023-06-26T05:25:20.000+00:00",
        "user": {
          "id": "1651091794630324226",
          "planetCode": "20600",
          "userName": "。",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/EVAowwWDAUwiaRibibWVbGooOhS1w19biadjiaHGyCtRviaR651Tm79PBJrnUAVjwFeI80pYFfFQMhiapZXiaqh5tFuReQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-05-17T03:49:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-04-26T05:12:14.000+00:00",
          "updateTime": "2023-05-18T03:49:59.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "面试",
          "游戏"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1664516564302450689",
        "title": "写了 7 年代码，第一次见这么狗血的小 Bug！",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/fCE2ufkb-mmexport1685609254865_edit_189398758157037(1).jpg",
        "language": null,
        "viewNum": 310,
        "thumbNum": 11,
        "favourNum": 0,
        "commentNum": 3,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-02T06:17:28.000+00:00",
        "updateTime": "2023-06-27T07:40:14.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1685,
          "coin": 170,
          "followeeNum": 838,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-06-27T05:59:46.000+00:00"
        },
        "tags": [
          "文章",
          "人工智能"
        ],
        "fileList": [],
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      }
    ],
    "total": "120",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "12"
  },
  "message": "ok"
}